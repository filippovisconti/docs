---
tags: [Algorithms, Nonoblivious-algorithms, Parallel-computing, Multithread]
title: "Non-oblivious Algorithms"
categories: dphpc lecture-notes
math: true
---

When talking about work and depth, we assume each loop iteration on a single PE is unit-cost (may contain multiple instructions!)

Given: $n$ values in linked list, looking for sum of all values ![](/assets/img/ScreenShot%202024-01-12%20at%2017.36.19.png)

> [!NOTE] Independent Set A set $ğ¼ âŠ‚ ğ‘†$ is called an independent set if no two elements in $ğ¼$ are connected!

![](/assets/img/ScreenShot%202024-01-12%20at%2017.44.00.png)

# Reduction on a linked list

## Sequential algorithm

```c
typedef struct elem {
 struct elem *next;
 int val;
} elem;

set S={all elems}
while (S != empty) {
 pick some i âˆˆ S;
 S = S â€“ i.next;
 i.val += i.next.val;
 i.next = i.next.next;
}
```

## Parallel algorithm

Basically the same algorithm, just working on independent subsets!

```c
set S={all elems}
while (S != empty) {
 pick independent subset I âˆˆ S;
 for(each ğ‘– âˆˆ ğ¼ do in parallel) {
  S = S â€“ i.next;
  i.val += i.next.val;
  i.next = i.next.next;
 }
}
```

Assuming picking a maximum ğ¼ is free, what are work and depth?

- $ğ‘Š = ğ‘› âˆ’ 1, ğ· = âŒˆ\log_2nâŒ‰$

### How to pick the independent set ğ‘°?

- Thatâ€™s now the whole trick!
- Itâ€™s simple if all linked values are consecutive in an array â€“ same as â€œstandardâ€ reduction!
  - There, we â€œcomputeâ€ (know?) independent sets up-front!

Irregular linked list though?

- Idea 1: find the order of elements â†’ requires parallel prefix sum, Dâ€™oh!
- Observation: if we pick $ğ¼ > ğœ†|ğ‘‰|$ in each iteration, we finish in logarithmic time!

Symmetry breaking:

- Assume ğ‘ processes work on ğ‘ consecutive nodes
- How to find the independent set?
  - They all look the same (well, only the first and last differ, they have no left/right neighbor)
  - Local decisions cannot be made

Introduce randomness to create local differences!

- Each node tosses a coin â†’ 0 or 1
- Let ğ¼ be the set of nodes such that `v` drew `1` and `v.next` drew `0`!
  - Show that I is indeed independent!
  - What is the probability that ğ‘£ âˆˆ ğ¼? $$P(v \in I)=\frac 1 4$$ ![](/assets/img/ScreenShot%202024-01-12%20at%2017.48.14.png)

### Optimizations

As the set shrinks, the random selection will get less efficient

- When ğ‘ is close to $ğ‘› ( |ğ‘†| )$ then most processors will fail to make useful progress
- Switch to a different algorithm: Recursive doubling!

```c
for (i=0; i â‰¤ âŒˆlog2ğ‘›âŒ‰; ++i) {
 for(each elem do in parallel) {
  elem.val += elem.next.val;
  elem.next = elem.next.next;
 }
}
```

Algorithm computes (reverse) prefix sum on the list! Result at original list head is overall sum

What are work and depth?

- $ğ‘Š = ğ‘›âŒˆ\log_2ğ‘›âŒ‰, ğ· = âŒˆ\log_2nâŒ‰$

# Prefix sum on a linked list

Didnâ€™t we just see it? Yes, but work-inefficient (if $p<<n$)! We extend the randomized symmetry-breaking reduction algorithms

- First step: run the reduction algorithm as before
- Second step: reinsert in reverse order of deletion When reinserting, add the value of their successor. ![](/assets/img/ScreenShot%202024-01-12%20at%2017.50.23.png)

How to implement this in practice?

- Either recursion or a stack!

# Nonoblivious graph algorithms - finding connected components

> [!NOTE] Connected Component A connected component of an undirected graph is a subgraph in which any two vertices are connected by a path and no vertex in the subgraph is connected to any vertices
> outside the subgraph. Each undirected graph $G = (V,E)$ contains one or multiple (at most $|V|$) connected components.

Straight forward and cheap to compute sequentially â€“ question: how?

- Any traversal algorithm in work $ğ‘‚ (ğ‘‰ + ğ¸)$ Seemingly trivial - becomes very interesting in parallel
- Our oblivious semiring-based algorithm was $ğ‘Š = ğ‘‚(ğ‘›^3\log ğ‘›), ğ· = ğ‘‚(log^2ğ‘›)$

FAR from work optimality! Question: can we do better by dropping obliviousness? ![](/assets/img/ScreenShot%202024-01-12%20at%2018.31.18.png)

{: .prompt-info} >

> 1. Initially, each vertex is a (singleton) supervertex
> 2. Successively merge neighboring supervertices
> 3. When no further merging is possible â†’ each supervertex is a component

Question is now only about the merging strategy

> A fixpoint algorithm proceeds iteratively and monotonically until it reaches a final state that is not left by iterating further

## Shiloach/Vishkinâ€™s algorithm

Pointer graph/forest:

- Define pointer array ğ‘ƒ
  - ğ‘ƒ[ğ‘–] is a pointer from ğ‘– to some other vertex
- We call the graph defined by ğ‘ƒ (excluding self loops) the pointer graph
- During the algorithm, ğ‘ƒ[ğ‘–] forms a forest such that
  - âˆ€ğ‘–: ğ‘–, ğ‘ƒ ğ‘– there exists a path from ğ‘– to ğ‘ƒ[ğ‘–] in the original graph!
- Initially, all `P[i] = i`
- The algorithm will run until each forest is a directed star pointing at the (smallest-id) root of the component

Supervertices:

- Initially, each vertex is its own supervertex
- Supervertices induce a graph - ğ‘†ğ‘– and ğ‘†ğ‘— are connected iff âˆƒ ğ‘¢, ğ‘£ âˆˆ ğ¸ with ğ‘¢ âˆˆ ğ‘†ğ‘– and ğ‘£ âˆˆ ğ‘†ğ‘—
- A supervertex is represented by its tree in ğ‘ƒ

### Key components

Algorithm proceeds in two operations:

- Hook â€“ merge connected supervertices (must be careful to not introduce cycles!)
- Shortcut â€“ turn trees into stars
- Repeat two steps iteratively until fixpoint is reached

![](/assets/img/ScreenShot%202024-01-12%20at%2018.35.44.png) ![](/assets/img/ScreenShot%202024-01-12%20at%2018.35.58.png)

Work and depth?

- $ğ‘Š = ğ‘‚ (ğ‘›^2\log ğ‘›) , ğ· = ğ‘‚(\log^2ğ‘›)$ (assuming conflicts are free!)
